# инфра

### Начало работы

Для запуска проекта нужна NodeJs (https://nodejs.org). Вместе с ней установятся пакетный менеджер `npm` и `npx` – этот позволяет вручную запсукать пакеты.

1. В корне проекта открываем терминал и устанавливаем все зависимости (они записаны в `package.json`):

```
npm install
```

2. И сразу можно запускать скрипты из `package.json`:
    1. `npm run build` – чтобы [вебпак](https://webpack.js.org) преобразовал наш сложный код в код, удобоваримый браузером (он называется билдом или бандлом, наш вебпак его помещает в папку `dist`)
    2. `npm run start-dev` – то же самое что `build`, но вебпак запускает процесс слежения за изменениями в файлах и обновляет билд

### Про package.json

Сам `package.json` – это манифест любого js приложения или пакета, там есть краткое описание, авторы, лицензия, конфиги для некоторых библиотек и тд.  
При установки зависимостей их название и версия автоматически попадают в `dependencies` или `dev-dependencies` (сами зависимости устанавливаются в `node_modules`);
чтобы зависимость попала в `dev-dep..` нужно писать `npm install <package-name> --save-dev`.
Туда принято добавлять то, что не попадает в итоговый бандл, например sass, eslint, typescript, все что связано с webpack и тд.  
Скрипты `scripts` пишутся руками разработчиков.

Файл `package-lock.json` генерируется полностью автоматически, он сохраняет всю инфу об установленных зависимостях – точную версию, место откуда скачали и тд, чтобы сделать проект более стабильным (в `package.json` хранится только диапазон допустимых версий, а значит если пользоваться только им, то через какое-то время мы можем получить более новую версию пакета и сломать проект).  
Если в проекте есть `package-lock.json`, то `npm install` устанавливает зависимости исключительно по его инфе и тогда на любой машине и в любое время мы будем получать одни и те же файлы.

### Про инфраструктуру

В проекте есть:

- Форматтер `prettier` – он следит за красотой кода (максимальная длина строки, лишние отступы, кавычки, переносы и тд). Его конфиг пишется в `.prettierrc`, настроек в нем немного, про них можно почитать в [доке](https://prettier.io/docs/en/options.html). Для его работы необходим пакет `prettier` в `package.json` (если vscode, то еще одноименное расширение). Приттер может быстро обработать файл и привести код в хороший вид по сочетанию клавиш (зависит от IDE и операционки)
- Линтер `eslint` – он следит за код-стайлом, принятым в вашей команде, и отлавливает баги (неиспользуемые переменные, неправильное обьявление или вызов функций и тд). Настроек в нем бесконечное колличество, можно попробовать почитать в доке, но лучше видосы на ютубе или статьи. Его конфиг в `.eslintrc.js`. Для работы нужен пакет `eslint` (если vscode, то еще одноименное расширение).  
     Можно сгененерировать `.eslintrc.js` автоматически, прописав в терминале `eslint --init`. Если использовать популярные код-стайлы (google, airbnb, facebook и тд) то велика вероятность получить несовместимость eslint-а, typescript-а и prettier. Если нет полного понимания как их совмещать, то лучше ответить на вопросы о своем кодстайле, тогда ничего лишнего не добавится.
- Язык `typescript` – добавляет псевдо строгую типизацию в JS (почему псевдо – типы пропадут после сборки и на продакшене их не будет, потому что браузер поддерживает только `js`). TS сильно ускоряет и упрощает разработку проектов любой сложности. Но порог входа сильно выше, чем в `js`. Его небольшой конфиг в `tsconfig.json`, он генерируется с помощью `tsc --init`.
- Сборщик `webpack` – он принимает наш входной файл (`entry` в конфиге `webpack.config.js`) и собирает все используемые в нем зависимости и наши файлы. Входных файлов может быть несколько, тогда на выходе получим несколько бандлов, что позволит пользователю скачивать только то, что нужно конкретно на этой странице. Когда вебпак отработает, то помещает получившиеся бандлы в `dist`.  
     Папки `dist` и `node_modules` не загружают в репозиторий `github`, потому что их легко воспроизвести на месте.  
     Весь конфиг вебпака пишется самостоятельно, из основного в нем есть:
    - `target` – для чего сборка? В браузере (`web`) поддерживаются одни технолгии, на сервере (`node`) другие. Мы пишем фронтенд, то есть приложение для браузера.
    - `entry` – все входные файлы, можно дать несколько входных файлов, чтобы получить несколько бандлов.
    - `output` – куда складывать полученную сборку?
    - `mode` – если выбрать продакшен-мод, то будет применяться больше оптимизаций.
    - `resolve` – настройки для import/export в нашем коде.
    - `optimization` – сюда можно подключить дополнительные оптимизации.
    - `module` – чем и как компилировать наши модули? (модуль – каждый файл, будь то js/css/png и тд).
    - `plugins` – плагины для вебпака, используемые в конфиге описал там же.
- Библиотека `React` – всё в `src`, здесь про нее не написал, но после лекции из ШРИ она не должна показаться сильно запутанной. Для работы нужен установленный `react` в `package.json` (уже есть) и лоадер вебпака, который обработает весь наш код (в конфиге).

Внутрянку вебпака более подробно расписал в `webpack.config.js`.

### Что делать с полученной сборкой

После сборки вебпака в папке `dist` мы имеем файлы .js .css и .html.  
Нельзя просто открыть .html и ожидать что все заработает – нам нужен маленький сервер, который сможет обрабатывать урлы, используемые нашим React-приложением.  
Можно поднять свой небольшой сервер с помощью библиотек `express.js` на языке `Node.JS` – это тот же JS, только работает в окружении NodeJS, установленного на компьютер (в проекте нет, можно посмотреть здесь на 9:50 https://www.youtube.com/watch?v=uNLaS0S2FmU).  
Или использовать `webpack-dev-server` (в проекте нет, можно посмотреть здесь https://www.youtube.com/watch?v=uNLaS0S2FmU), но насколько я знаю он подойдет только для разработки, а для продакшена все равно придется поднимать сервер.
